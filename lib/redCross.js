// Generated by CoffeeScript 1.10.0
(function() {
  var addDistance, async, config, deActivateShelters, mongo, mongoURI, parser, remapData, remapLatLong, run, saveAllShelters, schedule, startUpdateSchedule, translateData, update, updateShelters, utils;

  async = require('async');

  mongo = require('mongodb');

  parser = require('cron-parser');

  schedule = require('node-schedule');

  utils = require('./utils');

  config = require('./config.json');

  mongoURI = process.env.MONGO_URI || config.mongo.uri || 'mongodb://' + config.mongo.host + ':' + config.mongo.port + '/' + config.mongo.dbName;

  remapLatLong = function(shelter) {
    var latitude, longitude;
    latitude = parseFloat(shelter.lat);
    longitude = parseFloat(shelter.lng);
    shelter.active = true;
    shelter.city = shelter.city.toProperCase();
    shelter.location = {
      type: 'Point',
      coordinates: [longitude, latitude]
    };
    delete shelter.lat;
    delete shelter.lng;
    return shelter;
  };

  remapData = function(shelter, done) {
    shelter = remapLatLong(shelter);
    shelter.lastUpdated = new Date();
    return done(null, shelter);
  };

  translateData = function(shelters, next) {
    return async.map(shelters, remapData, next);
  };

  update = function(collection, query, update, next) {
    return mongo.MongoClient.connect(mongoURI, function(err, db) {
      collection = db.collection(collection);
      return collection.ensureIndex({
        location: '2dsphere'
      }, function(err) {
        var options;
        options = {
          safe: true,
          upsert: true
        };
        return collection.update(query, {
          '$set': update,
          '$setOnInsert': {
            created: new Date()
          }
        }, options, next);
      });
    });
  };

  saveAllShelters = function(shelters, done) {
    console.log("Updating " + shelters.length + " shelters " + (new Date()));
    return async.eachSeries(shelters, (function(shelter, next) {
      var query;
      query = {
        'location.coordinates': shelter.location.coordinates
      };
      return update('shelters', query, shelter, next);
    }), done);
  };

  deActivateShelters = function(done) {
    return mongo.MongoClient.connect(mongoURI, function(err, db) {
      var collection, options;
      collection = db.collection('shelters');
      options = {
        safe: true
      };
      return collection.update({}, {
        '$set': {
          active: false
        }
      }, options, done());
    });
  };

  updateShelters = function(done) {
    var sheltersCount;
    sheltersCount = 0;
    return async.waterfall([
      function(next) {
        return deActivateShelters(next);
      }, function(next) {
        return utils.getShelters(next);
      }, function(shelters, next) {
        return translateData(shelters, next);
      }, function(shelters, next) {
        sheltersCount = shelters.length;
        return saveAllShelters(shelters, next);
      }
    ], function(err) {
      return done(err, sheltersCount);
    });
  };

  startUpdateSchedule = function() {
    var interval;
    setTimeout((function() {
      return updateShelters(function(err, sheltersCount) {
        var log, time;
        time = Date.now();
        log = {
          err: err,
          time: time,
          sheltersCount: sheltersCount
        };
        return update('logs', log, log);
      });
    }), 1000);
    if (!config.cronUpdateSchedule) {
      console.log("Shelters not scheduled to update, set config cronUpdateSchedule to cron format");
      return;
    }
    interval = parser.parseExpression(config.cronUpdateSchedule);
    console.log("Shelters scheduled to update " + (interval.next().toString()));
    return schedule.scheduleJob(config.cronUpdateSchedule, function() {
      return updateShelters(function(err, sheltersCount) {
        var log, time;
        time = Date.now();
        log = {
          err: err,
          time: time,
          sheltersCount: sheltersCount
        };
        return update('logs', log, log, function(err, results) {
          if (err) {
            return next(err);
          }
          return results;
        });
      });
    });
  };

  run = function() {
    return startUpdateSchedule();
  };

  run();

  addDistance = function(shelters, coords, next) {
    var coordinates, i, lat, len, long, shelter, shelter_loc, user_loc;
    lat = coords.lat, long = coords.long;
    for (i = 0, len = shelters.length; i < len; i++) {
      shelter = shelters[i];
      coordinates = shelter.location.coordinates;
      shelter_loc = {
        lat: coordinates[1],
        long: coordinates[0]
      };
      user_loc = {
        lat: lat,
        long: long
      };
      shelter.distance = utils.calcDistance(user_loc, shelter_loc);
    }
    return next(null, shelters);
  };

  module.exports = {
    allShelters: function(req, res) {
      return mongo.MongoClient.connect(mongoURI, function(err, db) {
        var query, shelters;
        shelters = db.collection('shelters');
        query = req.query;
        if (query.active) {
          query.active = query.active === 'false' ? false : true;
        }
        return async.waterfall([
          function(next) {
            return shelters.find(query, next);
          }, function(results, next) {
            return results.toArray(next);
          }
        ], function(err, shelters) {
          if (err) {
            return res.send('Database error');
          }
          return res.send(shelters);
        });
      });
    },
    closestShelters: function(req, res) {
      return mongo.MongoClient.connect(mongoURI, function(err, db) {
        var city, coord, lat, long, query, ref, ref1, shelters;
        ref = req.params, city = ref.city, lat = ref.lat, long = ref.long;
        ref1 = [parseFloat(lat), parseFloat(long)], lat = ref1[0], long = ref1[1];
        shelters = db.collection('shelters');
        coord = {
          type: "Point",
          coordinates: [long, lat]
        };
        query = {
          location: {
            $near: {
              $geometry: coord
            }
          }
        };
        if (req.active) {
          query.active = query.active === 'false' ? false : true;
        }
        return async.waterfall([
          function(next) {
            return shelters.find(query, next);
          }, function(results, next) {
            return results.toArray(next);
          }, function(shelters, next) {
            return addDistance(shelters, {
              lat: lat,
              long: long
            }, next);
          }
        ], function(err, shelters) {
          if (err) {
            return res.send({
              error: "Database error - " + err
            });
          }
          return res.send(shelters);
        });
      });
    }
  };

}).call(this);
