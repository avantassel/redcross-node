// Generated by CoffeeScript 1.10.0
(function() {
  var addDistance, async, config, db, dbName, deActivateShelters, host, mongo, open, parser, port, ref, remapData, remapLatLong, run, saveAllShelters, schedule, server, startUpdateSchedule, translateData, update, updateShelters, utils;

  async = require('async');

  mongo = require('mongodb');

  parser = require('cron-parser');

  schedule = require('node-schedule');

  utils = require('./utils');

  config = require('./config.json');

  ref = config.mongo, host = ref.host, port = ref.port, dbName = ref.dbName;

  server = new mongo.Server(host, port, {
    auto_reconnect: true
  });

  db = new mongo.Db(dbName, server, {
    journal: true
  });

  open = function(next) {
    return db.open(next);
  };

  remapLatLong = function(shelter) {
    var latitude, longitude;
    latitude = parseFloat(shelter.lat);
    longitude = parseFloat(shelter.lng);
    shelter.active = true;
    shelter.city = shelter.city.toProperCase();
    shelter.location = {
      type: 'Point',
      coordinates: [longitude, latitude]
    };
    delete shelter.lat;
    delete shelter.lng;
    return shelter;
  };

  remapData = function(shelter, done) {
    shelter = remapLatLong(shelter);
    shelter.lastUpdated = new Date();
    return done(null, shelter);
  };

  translateData = function(shelters, next) {
    return async.map(shelters, remapData, next);
  };

  update = function(db, collection, query, update, next) {
    collection = db.collection(collection);
    return collection.ensureIndex({
      location: '2dsphere'
    }, function(err) {
      var options;
      options = {
        safe: true,
        upsert: true
      };
      return collection.update(query, {
        '$set': update,
        '$setOnInsert': {
          created: new Date()
        }
      }, options, next);
    });
  };

  saveAllShelters = function(db, shelters, done) {
    console.log("Updating " + shelters.length + " shelters " + (new Date()));
    return async.eachSeries(shelters, (function(shelter, next) {
      var query;
      query = {
        'location.coordinates': shelter.location.coordinates
      };
      return update(db, 'shelters', query, shelter, next);
    }), done);
  };

  deActivateShelters = function(db, done) {
    var collection, options;
    collection = db.collection('shelters');
    options = {
      safe: true
    };
    return collection.update({}, {
      '$set': {
        active: false
      }
    }, options, done());
  };

  updateShelters = function(db, done) {
    var sheltersCount;
    sheltersCount = 0;
    return async.waterfall([
      function(next) {
        return deActivateShelters(db, next);
      }, function(next) {
        return utils.getShelters(next);
      }, function(shelters, next) {
        return translateData(shelters, next);
      }, function(shelters, next) {
        sheltersCount = shelters.length;
        return saveAllShelters(db, shelters, next);
      }
    ], function(err) {
      return done(err, sheltersCount);
    });
  };

  startUpdateSchedule = function(done) {
    var interval;
    setTimeout((function() {
      return updateShelters(db, function(err, sheltersCount) {
        var log, time;
        time = Date.now();
        log = {
          err: err,
          time: time,
          sheltersCount: sheltersCount
        };
        return update(db, 'logs', log, log);
      });
    }), 1000);
    if (!config.cronUpdateSchedule) {
      console.log("Shelters not scheduled to update, set config cronUpdateSchedule to cron format");
      done;
    }
    interval = parser.parseExpression(config.cronUpdateSchedule);
    console.log("Shelters scheduled to update " + (interval.next().toString()));
    schedule.scheduleJob(config.cronUpdateSchedule, function() {
      return updateShelters(db, function(err, sheltersCount) {
        var log, time;
        time = Date.now();
        log = {
          err: err,
          time: time,
          sheltersCount: sheltersCount
        };
        return update(db, 'logs', log, log, function(err, results) {
          if (err) {
            return next(err);
          }
          return results;
        });
      });
    });
    return done;
  };

  run = function() {
    return async.waterfall([
      function(next) {
        return open(next);
      }, function(next) {
        return startUpdateSchedule(next);
      }
    ], function(err) {
      return console.log("Error " + err + ", stopped updating shelters");
    });
  };

  run();

  addDistance = function(shelters, coords, next) {
    var coordinates, i, lat, len, long, shelter, shelter_loc, user_loc;
    lat = coords.lat, long = coords.long;
    for (i = 0, len = shelters.length; i < len; i++) {
      shelter = shelters[i];
      coordinates = shelter.location.coordinates;
      shelter_loc = {
        lat: coordinates[1],
        long: coordinates[0]
      };
      user_loc = {
        lat: lat,
        long: long
      };
      shelter.distance = utils.calcDistance(user_loc, shelter_loc);
    }
    return next(null, shelters);
  };

  module.exports = {
    allShelters: function(req, res) {
      var query, shelters;
      shelters = db.collection('shelters');
      query = req.query;
      if (query.active) {
        query.active = query.active === 'false' ? false : true;
      }
      return async.waterfall([
        function(next) {
          return shelters.find(query, next);
        }, function(results, next) {
          return results.toArray(next);
        }
      ], function(err, shelters) {
        if (err) {
          return res.send('Database error');
        }
        return res.send(shelters);
      });
    },
    closestShelters: function(req, res) {
      var city, coord, lat, long, query, ref1, ref2, shelters;
      ref1 = req.params, city = ref1.city, lat = ref1.lat, long = ref1.long;
      ref2 = [parseFloat(lat), parseFloat(long)], lat = ref2[0], long = ref2[1];
      shelters = db.collection('shelters');
      coord = {
        type: "Point",
        coordinates: [long, lat]
      };
      query = {
        location: {
          $near: {
            $geometry: coord
          }
        }
      };
      if (req.active) {
        query.active = query.active === 'false' ? false : true;
      }
      return async.waterfall([
        function(next) {
          return shelters.find(query, next);
        }, function(results, next) {
          return results.toArray(next);
        }, function(shelters, next) {
          return addDistance(shelters, {
            lat: lat,
            long: long
          }, next);
        }
      ], function(err, shelters) {
        if (err) {
          return res.send({
            error: "Database error - " + err
          });
        }
        return res.send(shelters);
      });
    }
  };

}).call(this);
